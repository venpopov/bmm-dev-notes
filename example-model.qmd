# Example model file {#sec-example-model}

All models in the package are defined as S3 classes and follow a strict template. This allows us to implement general methods for handling model fitting, data checking, and postprocessing. Each model has an internal function that defines the model and its parameters, and a user-facing alias. Let's look at how two models are implemented - the IMM model, which uses both general class and specific model methods, but no custom stan code, and the SDM model, which depends heavily on custom stan code. If you use the `use_model_template()` function, all sections bellows will be automatically generated for your model.

## The Interference Measurement Model (IMM)

The model is defined in the file `R/bmm_model_IMM.R.` Let's go through the different parts.

### Model definition

The full IMM model is defined in the following internal model class:

``` r
.model_IMMfull <- function(non_targets, setsize, spaPos, ...) {
  out <- list(
    vars = nlist(non_targets, setsize, spaPos),
    info = list(
      domain = "Visual working memory",
      task = "Continuous reproduction",
      name = "Interference measurement model by Oberauer and Lin (2017).",
      version = "full",
      citation = paste0("Oberauer, K., & Lin, H.Y. (2017). An interference model ",
                        "of visual working memory. Psychological Review, 124(1), 21-59"),
      requirements = paste0('- The response vairable should be in radians and ',
                            'represent the angular error relative to the target\n  ',
                            '- The non-target variables should be in radians and be ',
                            'centered relative to the target'),
      parameters = list(
        kappa = "Concentration parameter of the von Mises distribution (log scale)",
        a = "General activation of memory items",
        b = "Background activation (internally fixed to 0)",
        c = "Context activation",
        s = "Spatial similarity gradient"
      )
    ))
  class(out) <- c("bmmmodel","vwm","nontargets","IMMspatial","IMMfull")
  out
}
```

Here is a brief explanation of the different components of the model definition:

`vars`: a list of variables that are required for the model. This is used to check if the data contains all necessary information for fitting the model. In the example above, the IMM model requires the names of the non-target variables, the setsize and the variable specifying the spatial distance between the memory items. The user has to provide these variables in the data frame that is passed to the `fit_model` function

`info`: contains information about the model, such as the domain, task, name, citation, version, requirements, and parameters. This information is used to generate the documentation for the model.

`class`: is the most important part. It contains the class of the model. This is used by generic S3 methods to perform data checks and model configuration. The classes should be ordered from most general to most specific. A general class exists when the same operations can be performed on multiple models. For example, the '3p', 'IMMabc', 'IMMbsc' and 'IMMfull' models all have non-targets and setsize arguments, so the same data checks can be performed on all of them, represented by the class `nontargets`. The first class should always be `bmmmodel`, which is the main class for all models. The last class should be the specific model name, in this case `IMMfull`. 

### Model alias

The model alias is a user-facing function that calls the internal model function. It is defined as follows:

``` r
# user facing alias
#' @title `r .model_IMMfull(NA, NA, NA)$info$name`
#' @name IMM
#' @details `r model_info(IMMfull(NA, NA, NA), components =c('domain', 'task', 'name', 'citation'))`
#' #### Version: `IMMfull`
#' `r model_info(IMMfull(NA, NA, NA), components =c('requirements', 'parameters'))`
#' #### Version: `IMMbsc`
#' `r model_info(IMMbsc(NA, NA, NA), components =c('requirements', 'parameters'))`
#' #### Version: `IMMabc`
#' `r model_info(IMMabc(NA, NA, NA), components =c('requirements', 'parameters'))`
#' @param non_targets A character vector with the names of the non-target variables.
#'   The non_target variables should be in radians and be centered relative to the
#'   target.
#' @param setsize Name of the column containing the set size variable (if
#'   setsize varies) or a numeric value for the setsize, if the setsize is
#'   fixed.
#' @param spaPos A vector of names of the columns containing the spatial distances of
#'   non-target items to the target item. Only necessary for the `IMMbsc` and `IMMfull` models
#' @param ... used internally for testing, ignore it
#' @return An object of class `bmmmodel`
#' @keywords bmmmodel
#' @export
IMMfull <- .model_IMMfull

#' @rdname IMM
#' @keywords bmmmodel
#' @export
IMMbsc <- .model_IMMbsc

#' @rdname IMM
#' @keywords bmmmodel
#' @export
IMMabc <- .model_IMMabc
```

The details will be filled out automatically from the model definition. The example for the IMM model also includes the aliases for the other versions of the IMM model, which are `IMMbsc` and `IMMabc`, and does some fancy formatting to include documentation about all versions of the model in the same help file.

### check_data() methods

Each model should have a `check_data.modelname()` method that checks if the data contains all necessary information for fitting the model. For the IMM, all three versions of the model share the same data requirements, so check_data is defined for the more general class, `IMMspatial`. The method is defined as follows:

``` r
#' @export
check_data.IMMspatial <- function(model, data, formula) {
  spaPos <- model$vars$spaPos
  max_setsize <- attr(data, 'max_setsize')

  if (length(spaPos) < max_setsize - 1) {
    stop(paste0("The number of columns for spatial positions in the argument",
                "'spaPos' is less than max(setsize)-1"))
  } else if (length(spaPos) > max_setsize-1) {
    stop(paste0("The number of columns for spatial positions in the argument",
                "spaPos'' is more than max(setsize)-1"))
  }

  if (max(abs(data[,spaPos]), na.rm=T) > 10) {
    data[,spaPos] <- data[,spaPos]*pi/180
    warning('It appears your spatial position variables are in degrees. We will transform it to radians.')
  }
  # wrap spatial position variables around the circle (range = -pi to pi)
  data[,spaPos] <- bmm::wrap(data[,spaPos])
  data = NextMethod("check_data")

  return(data)
}
```

The IMM models share methods with the `mixture3p` model, all of which are of class `nontargets` so the `check_data.nontargets` method is defined in the general file `R/helpers-data.R`. If you are adding a new model, you should check if the data requirements are similar to any existing model and define the `check_data` method only for the methods that are unique to your model.

The `check_data.mymodel()` function should always take the arguments `model`, `data`, and `formula` and return the data with the necessary transformations. It should also call `data = NextMethod("check_data")` to call the check_data method of the more general class.

### configure_model() methods

The configure_model.mymodel() method is where you specify the model formula, the family, any custom code, and the priors. The method is defined as follows for the IMM model:

(we show only the `IMMfull` version)

``` r
#' @export
configure_model.IMMfull <- function(model, data, formula) {
  # retrieve arguments from the data check
  max_setsize <- attr(data, 'max_setsize')
  lure_idx_vars <- attr(data, "lure_idx_vars")
  non_targets <- model$vars$non_targets
  setsize_var <- model$vars$setsize
  spaPos <- model$vars$spaPos

  # names for parameters
  kappa_nts <- paste0('kappa', 2:max_setsize)
  kappa_unif <- paste0('kappa',max_setsize + 1)
  theta_nts <- paste0('theta',2:max_setsize)
  mu_nts <- paste0('mu', 2:max_setsize)
  mu_unif <- paste0('mu', max_setsize + 1)

  # construct formula
  formula <- formula +
    brms::lf(mu1 ~ 1) +
    glue_lf(kappa_unif,' ~ 1') +
    glue_lf(mu_unif, ' ~ 1') +
    brms::nlf(theta1 ~ c + a) +
    brms::nlf(kappa1 ~ kappa) +
    brms::nlf(expS ~ exp(s))
  for (i in 1:(max_setsize-1)) {
    formula <- formula +
      glue_nlf(kappa_nts[i], ' ~ kappa') +
      glue_nlf(theta_nts[i], ' ~ ', lure_idx_vars[i], '*(exp(-expS*',spaPos[i],')*c + a) + ',
               '(1-', lure_idx_vars[i], ')*(-100)') +
      glue_nlf(mu_nts[i], ' ~ ', non_targets[i])
  }

  # define mixture family
  vm_list = lapply(1:(max_setsize+1), function(x) brms::von_mises(link="identity"))
  vm_list$order = "none"
  family <- brms::do_call(brms::mixture, vm_list)

  # define prior
  prior <- # fix mean of the first von Mises to zero
    brms::prior_("constant(0)", class = "Intercept", dpar = "mu1") +
    # fix mean of the guessing distribution to zero
    brms::prior_("constant(0)", class = "Intercept", dpar = mu_unif) +
    # fix kappa of the second von Mises to (alomst) zero
    brms::prior_("constant(-100)", class = "Intercept", dpar = kappa_unif) +
    # set reasonable priors fpr the to be estimated parameters
    brms::prior_("normal(2, 1)", class = "b", nlpar = "kappa") +
    brms::prior_("normal(0, 1)", class = "b", nlpar = "c") +
    brms::prior_("normal(0, 1)", class = "b", nlpar = "a") +
    brms::prior_("normal(0, 1)", class = "b", nlpar = "s")

  # if there is setsize 1 in the data, set constant prior over thetant for setsize1
  if ((1 %in% data$ss_numeric) && !is.numeric(data[[setsize_var]])) {
    prior <- prior +
      brms::prior_("constant(0)", class="b", coef = paste0(setsize_var, 1), nlpar="a")+
      brms::prior_("constant(0)", class="b", coef = paste0(setsize_var, 1), nlpar="s")
  }

  out <- nlist(formula, data, family, prior)
  return(out)
}
```

The configure_model method should always take the arguments `model`, `data`, and `formula` and return a named list with the formula, the data, the family, and the prior. 

## The Signal Discrimination Model (SDM)

The SDM model is defined in the file `R/bmm_model_SDM.R`. The SDM model is a bit more complex than the IMM model, as it requires custom stan code. Let's go through the different parts. As before, we start with the model definition.

### Model definition

``` r
.model_sdmSimple <- function(...) {
   out <- list(
      vars = nlist(),
      info = list(
         domain = 'Visual working memory',
         task = 'Continuous reproduction',
         name = 'Signal Discrimination Model (SDM) by Oberauer (2023)',
         citation = paste0('Oberauer, K. (2023). Measurement models for visual working memory - ',
                           'A factorial model comparison. Psychological Review, 130(3), 841-852'),
         version = 'Simple (no non-targets)',
         requirements = '- The response variable should be in radians and represent the angular error relative to the target',
         parameters = list(
            # mu = 'Location parameter of the SDM distribution (in radians; fixed internally to 0)',
            c = 'Memory strength parameter of the SDM distribution',
            kappa = 'Precision parameter of the SDM distribution (log scale)'
         )
      ))
   class(out) <- c('bmmmodel', 'vwm', 'sdmSimple')
   out
}
```

The model definition is similar to the IMM model, but the SDM model does not require non-target variables, so the `vars` list is empty. The `class` is also different, as the SDM model is not a subclass of the IMM model. We'll skip the alias for the SDM model, as it is similar for every model.

### check_data() methods

The SDM does not require special data checks beyond it's shared class with other `vwm` models, so we don't need to define a `check_data.sdmSimple` method. The `check_data.vwm` method is defined in the general file `R/helpers-data.R`.

### configure_model() methods

The configure_model method for the SDM model is a bit more complex than for the IMM model, as it requires custom stan code. The method is defined as follows:

``` r
#' @export
configure_model.sdmSimple <- function(model, data, formula) {
    # construct the family
    # note - c has a log link, but I've coded it manually for computational efficiency
    sdm_simple <- brms::custom_family(
      "sdm_simple", dpars = c("mu", "c","kappa"),
      links = c("identity","identity", "log"), lb = c(NA, NA, NA),
      type = "real", loop=FALSE,
    )
    family <- sdm_simple

    # prepare initial stanvars to pass to brms, model formula and priors
    stan_funs <- readChar('inst/stan_chunks/sdmSimple_funs.stan',
                          file.info('inst/stan_chunks/sdmSimple_funs.stan')$size)
    stan_tdata <- readChar('inst/stan_chunks/sdmSimple_tdata.stan',
                           file.info('inst/stan_chunks/sdmSimple_tdata.stan')$size)
    stan_likelihood <- readChar('inst/stan_chunks/sdmSimple_likelihood.stan',
                               file.info('inst/stan_chunks/sdmSimple_likelihood.stan')$size)
    stanvars <- brms::stanvar(scode = stan_funs, block = "functions") +
      brms::stanvar(scode = stan_tdata, block = 'tdata') +
      brms::stanvar(scode = stan_likelihood, block = 'likelihood', position="end")


   # construct the default prior
   # TODO: add a proper prior
   prior <-
     # fix mu to 0 (when I change mu to be the center, not c)
     brms::prior_("constant(0)", class = "Intercept", dpar = "mu")


   # return the list
   out <- nlist(formula, data, family, prior, stanvars)
   return(out)
}
```

**Lines 5-10** use the `brms::custom_family` function to define a custom family for the SDM model. The `dpars` argument specifies the parameters of the model, and the `links` argument specifies the link functions for the parameters. For more information, see [here](https://cran.r-project.org/web/packages/brms/vignettes/brms_customfamilies.html)

**Lines 13-22** read the custom stan code from the `inst/stan_chunks` directory. The `stanvars` object is used to pass custom stan code to the `brms` package. The `stanvars` object is a list of `brms::stanvar` objects, each of which contains the stan code for a specific part of the model. There is a separate `.stan` file for each part of the stan code, and each file is read into a separate `brms::stanvar` object.

The rest is the same as for the IMM model. 

We will now look at how to construct all these parts for a new model. Hint: you don't have to do it manually, you can use the `use_model_template()` function to generate the template for your model.



