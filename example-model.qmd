# Example model file {#sec-example-model}

All models in the package are defined as S3 classes and follow a strict template. This allows us to implement general methods for handling model fitting, data checking, and post-processing. Each model has an internal function that defines the model and its parameters, and a user-facing alias. Let's look at how two models are implemented - the IMM model, which uses both general class and specific model methods, but no custom stan code, and the SDM model, which depends heavily on custom stan code. If you use the `use_model_template()` function, all sections bellows will be automatically generated for your model.

## The Interference Measurement Model (IMM)

The model is defined in the file `R/bmm_model_IMM.R.` Let's go through the different parts.

### Model definition

The full IMM model is defined in the following internal model class:

``` r
.model_IMMfull <- function(resp_err,  nt_features, nt_distance, setsize, ...) {
  out <- list(
    resp_vars = nlist(resp_err),
    other_vars = nlist(nt_features, nt_distance, setsize),
    info = list(
      domain = "Visual working memory",
      task = "Continuous reproduction",
      name = "Interference measurement model by Oberauer and Lin (2017).",
      version = "full",
      citation = paste0("Oberauer, K., & Lin, H.Y. (2017). An interference model ",
                        "of visual working memory. Psychological Review, 124(1), 21-59"),
      requirements = paste0('- The response vairable should be in radians and ',
                            'represent the angular error relative to the target\n  ',
                            '- The non-target features should be in radians and be ',
                            'centered relative to the target'),
      parameters = list(
        mu1 = paste0("Location parameter of the von Mises distribution for memory responses",
                     "(in radians). Fixed internally to 0 by default."),
        kappa = "Concentration parameter of the von Mises distribution (log scale)",
        a = "General activation of memory items",
        c = "Context activation",
        s = "Spatial similarity gradient"
      ),
      fixed_parameters = list(
        mu1 = 0
      )),
    void_mu = FALSE
  )
  class(out) <- c("bmmmodel","vwm","nontargets","IMMspatial","IMMfull")
  out
}
```

Here is a brief explanation of the different components of the model definition:

`resp_vars`: a list of response variables that the model will be fitted to. These variables will be used to construct the `brmsformula` passed to `brms` together with the `bmmformula` and the `parameters` of the model. The user has to provide these variables in the data frame that is passed to the `fit_model` function

`other_vars:` a list of additional variables that are required for the model. This is used to check if the data contains all necessary information for fitting the model. In the example above, the IMM model requires the names of the variables specifying the non-target features relative to the target, the variables specifying the distance of the non-targets to the target, and the setsize. The user has to provide these variables in the data frame that is passed to the `fit_model` function

`info`: contains information about the model, such as the domain, task, name, citation, version, requirements, and parameters. This information is used to check if the `bmmformula` contains linear model formulas for all model parameters, and also specify defaults for `fixed_parameters`. In addition, the info is used to generate the documentation for the model.

`void_mu:` For models using a custom family that do not contain a `location` or `mu` parameter, for example the diffusion model, we recommend setting up a `void_mu` parameter. This avoids arbitrarily using one of the model parameters as the `mu` parameter.

`class`: is the most important part. It contains the class of the model. This is used by generic S3 methods to perform data checks and model configuration. The classes should be ordered from most general to most specific. A general class exists when the same operations can be performed on multiple models. For example, the '3p', 'IMMabc', 'IMMbsc' and 'IMMfull' models all have non-targets and setsize arguments, so the same data checks can be performed on all of them, represented by the class `nontargets`. The first class should always be `bmmmodel`, which is the main class for all models. The last class should be the specific model name, in this case `IMMfull`.

### Model alias

The model alias is a user-facing function that calls the internal model function. It is defined as follows:

``` r
# user facing alias

#' @title `r .model_IMMfull(NA, NA, NA, NA)$info$name`
#' @name IMM
#' @details `r model_info(IMMfull(NA, NA, NA, NA), components =c('domain', 'task', 'name', 'citation'))`
#' #### Version: `IMMfull`
#' `r model_info(IMMfull(NA, NA, NA, NA), components =c('requirements', 'parameters'))`
#' #### Version: `IMMbsc`
#' `r model_info(IMMbsc(NA, NA, NA, NA), components =c('requirements', 'parameters'))`
#' #### Version: `IMMabc`
#' `r model_info(IMMabc(NA, NA, NA), components =c('requirements', 'parameters'))`
#'
#' Additionally, all IMM models have an internal parameter that is fixed to 0 to
#' allow the model to be identifiable. This parameter is not estimated and is not
#' included in the model formula. The parameter is:
#'
#'   - b = "Background activation (internally fixed to 0)"
#'
#' @param resp_err The name of the variable in the provided dataset containing the
#'   response error. The response Error should code the response relative to the to-be-recalled
#'   target in radians. You can transform the response error in degrees to radian using the `deg2rad` function.
#' @param nt_features A character vector with the names of the non-target variables.
#'   The non_target variables should be in radians and be centered relative to the
#'   target.
#' @param nt_distance A vector of names of the columns containing the distances of
#'   non-target items to the target item. Only necessary for the `IMMbsc` and `IMMfull` models
#' @param setsize Name of the column containing the set size variable (if
#'   setsize varies) or a numeric value for the setsize, if the setsize is
#'   fixed.
#' @param ... used internally for testing, ignore it
#' @return An object of class `bmmmodel`
#' @keywords bmmmodel
#' @export
IMMfull <- .model_IMMfull

#' @rdname IMM
#' @keywords bmmmodel
#' @export
IMMbsc <- .model_IMMbsc

#' @rdname IMM
#' @keywords bmmmodel
#' @export
IMMabc <- .model_IMMabc
```

The details will be filled out automatically from the model definition. The example for the IMM model also includes the aliases for the other versions of the IMM model, which are `IMMbsc` and `IMMabc`, and does some fancy formatting to include documentation about all versions of the model in the same help file.

### check_data() methods

Each model should have a `check_data.modelname()` method that checks if the data contains all necessary information for fitting the model. For the IMM, all three versions of the model share the same data requirements, so check_data is defined for the more general class, `IMMspatial`. The method is defined as follows:

``` r
check_data.IMMspatial <- function(model, data, formula) {
  nt_distance <- model$other_vars$nt_distance
  max_setsize <- attr(data, 'max_setsize')

  if (length(nt_distance) < max_setsize - 1) {
    stop(paste0("The number of columns for spatial positions in the argument ",
                "'nt_distance' is less than max(setsize)-1"))
  } else if (length(nt_distance) > max_setsize - 1) {
    stop(paste0("The number of columns for spatial positions in the argument ",
                "'nt_distance' is more than max(setsize)-1"))
  }

  if (any(data[,nt_distance] < 0)) {
    stop('Somve values of the spatial distance variables in the data are negative.\n
         All spatial distances to the target need to be postive.')
  }

  data = NextMethod("check_data")

  return(data)
}
```

The IMM models share methods with the `mixture3p` model, all of which are of class `nontargets` so the `check_data.nontargets` method is defined in the general file `R/helpers-data.R`. If you are adding a new model, you should check if the data requirements are similar to any existing model and define the `check_data` method only for the methods that are unique to your model.

The `check_data.mymodel()` function should always take the arguments `model`, `data`, and `formula` and return the data with the necessary transformations. It should also call `data = NextMethod("check_data")` to call the check_data method of the more general class.

### configure_model() methods

The configure_model.mymodel() method is where you specify the model formula, the family, any custom code, and the priors. The method is defined as follows for the IMM model:

(we show only the `IMMfull` version)

``` r
configure_model.IMMfull <- function(model, data, formula) {
  # retrieve arguments from the data check
  max_setsize <- attr(data, 'max_setsize')
  lure_idx_vars <- attr(data, "lure_idx_vars")
  nt_features <- model$other_vars$nt_features
  setsize_var <- model$other_vars$setsize
  nt_distance <- model$other_vars$nt_distance

  # construct main brms formula from the bmm formula
  bmm_formula <- formula
  formula <- bmf2bf(model, bmm_formula)

  # additional internal terms for the mixture model formula
  kappa_nts <- paste0('kappa', 2:max_setsize)
  kappa_unif <- paste0('kappa',max_setsize + 1)
  theta_nts <- paste0('theta',2:max_setsize)
  mu_nts <- paste0('mu', 2:max_setsize)
  mu_unif <- paste0('mu', max_setsize + 1)

  formula <- formula +
    glue_lf(kappa_unif,' ~ 1') +
    glue_lf(mu_unif, ' ~ 1') +
    brms::nlf(theta1 ~ c + a) +
    brms::nlf(kappa1 ~ kappa) +
    brms::nlf(expS ~ exp(s))

  for (i in 1:(max_setsize - 1)) {
    formula <- formula +
      glue_nlf(kappa_nts[i], ' ~ kappa') +
      glue_nlf(theta_nts[i], ' ~ ', lure_idx_vars[i], '*(exp(-expS*',nt_distance[i],')*c + a) + ',
               '(1-', lure_idx_vars[i], ')*(-100)') +
      glue_nlf(mu_nts[i], ' ~ ', nt_features[i])
  }

  # define mixture family
  vm_list = lapply(1:(max_setsize + 1), function(x) brms::von_mises(link = "identity"))
  vm_list$order = "none"
  family <- brms::do_call(brms::mixture, vm_list)

  # define prior
  additional_constants <- list()
  additional_constants[[kappa_unif]] <- -100
  additional_constants[[mu_unif]] <- 0
  prior <- fixed_pars_priors(model, additional_constants) +
    brms::prior_("normal(2, 1)", class = "b", nlpar = "kappa") +
    brms::prior_("normal(0, 1)", class = "b", nlpar = "c") +
    brms::prior_("normal(0, 1)", class = "b", nlpar = "a") +
    brms::prior_("normal(0, 1)", class = "b", nlpar = "s")

  # if there is setsize 1 in the data, set constant prior over thetant for setsize1
  if ((1 %in% data$ss_numeric) && !is.numeric(data[[setsize_var]])) {
    prior <- prior +
      brms::prior_("constant(0)", class = "b", coef = paste0(setsize_var, 1), nlpar = "a") +
      brms::prior_("constant(0)", class = "b", coef = paste0(setsize_var, 1), nlpar = "s")
  }

  out <- nlist(formula, data, family, prior)
  return(out)
}
```

The configure_model method should always take the arguments `model`, `data`, and `formula` (as a `bmmformula)` and return a named list with the formula (as a `brmsformula`), the data, the family, and the priors.

Inside the configure_model method the `brmsformula` is generated using the `bmf2bf` function. This function converts the `bmmformula` passed to `fit_model` function into a `brmsformula` based on the information for the response variables provided in the `bmmmodel` object. There is a general method in `R/helpers-formula.R` to construct the formula for all models with a single response variable.

``` r
# default method for all bmmmodels with 1 response variable
#' @export
bmf2bf.bmmmodel <- function(model, formula) {
  # check if the model has only one response variable and extract if TRUE
  resp <- model$resp_vars
  if (length(resp) > 1) {
    formula <- NextMethod("bmf2bf")
    return(formula)
  }
  resp <- resp[[1]]

  # set base brms formula based on response
  brms_formula <- brms::bf(paste0(resp, "~ 1"))

  # for each dependent parameter, check if it is used as a non-linear predictor of
  # another parameter and add the corresponding brms function
  dpars <- names(formula)
  for (dpar in dpars) {
    pform <- formula[[dpar]]
    predictors <- rhs_vars(pform)
    if (any(predictors %in% dpars)) {
      brms_formula <- brms_formula + brms::nlf(pform)
    } else {
      brms_formula <- brms_formula + brms::lf(pform)
    }
  }
  brms_formula
}
```

For models with more than one response variable, you will have to provide a model specific method of `bmf2bf.myModel` to convert the `bmmformula` into the `brmsformula` . This is done to avoid users having to specify complicated and long formulas specifying all additional response information in the `brmsformula` themselves. For more detailed information on the use of additional response information in a `brmsformula` please see the `brmsformula` [documentation](https://rdrr.io/cran/brms/man/brmsformula.html).

## The Signal Discrimination Model (SDM)

The SDM model is defined in the file `R/bmm_model_SDM.R`. The SDM model differs in the configuration compared to the IMM model, as it requires custom STAN code. Let's go through the different parts. As before, we start with the model definition.

### Model definition

``` r
.model_sdmSimple <- function(resp_err, ...) {
   out <- list(
      resp_vars = nlist(resp_err),
      other_vars = nlist(),
      info = list(
         domain = 'Visual working memory',
         task = 'Continuous reproduction',
         name = 'Signal Discrimination Model (SDM) by Oberauer (2023)',
         citation = paste0('Oberauer, K. (2023). Measurement models for visual working memory - ',
                           'A factorial model comparison. Psychological Review, 130(3), 841-852'),
         version = 'Simple (no non-targets)',
         requirements = '- The response variable should be in radians and represent the angular error relative to the target',
         parameters = list(
            mu = 'Location parameter of the SDM distribution (in radians; by default fixed internally to 0)',
            c = 'Memory strength parameter of the SDM distribution',
            kappa = 'Precision parameter of the SDM distribution (log scale)'
         ),
         fixed_parameters = list(
            mu = 0
         )),
      void_mu = FALSE
   )
   class(out) <- c('bmmmodel', 'vwm', 'sdmSimple')
   out
}
```

The model definition is similar to the IMM model, but the SDM model only requires the user to specify the response error, but not additional variables such as non-target variables. The `class` is also different, as the SDM model is not a subclass of the IMM model. We'll skip the alias for the SDM model, as it is similar for every model.

### check_data() methods

The SDM does not require special data checks beyond it's shared class with other `vwm` models, so we don't need to define a `check_data.sdmSimple` method. The `check_data.vwm` method is defined in the general file `R/helpers-data.R`.

### configure_model() methods

The configure_model method for the SDM model is different compared to the IMM model, as it requires custom STAN code. The method is defined as follows:

``` r
#' @export
configure_model.sdmSimple <- function(model, data, formula) {
    # construct the family
    # note - c has a log link, but I've coded it manually for computational efficiency
    sdm_simple <- brms::custom_family(
      "sdm_simple", dpars = c("mu", "c","kappa"),
      links = c("identity","identity", "log"), lb = c(NA, NA, NA),
      type = "real", loop=FALSE,
    )
    family <- sdm_simple

    # prepare initial stanvars to pass to brms, model formula and priors
    sc_path <- system.file("stan_chunks", package="bmm")
    stan_funs <- read_lines2(paste0(sc_path, '/sdmSimple_funs.stan'))
    stan_tdata <- read_lines2(paste0(sc_path, '/sdmSimple_tdata.stan'))
    stan_likelihood <- read_lines2(paste0(sc_path, '/sdmSimple_likelihood.stan'))
    stanvars <- brms::stanvar(scode = stan_funs, block = "functions") +
      brms::stanvar(scode = stan_tdata, block = 'tdata') +
      brms::stanvar(scode = stan_likelihood, block = 'likelihood', position ="end")

    # construct main brms formula from the bmm formula
    bmm_formula <- formula
    formula <- bmf2bf(model, bmm_formula)

    # construct the default prior
    # TODO: for now it just fixes mu to 0, I have to add proper priors
    prior <- fixed_pars_priors(model)

    # set initial values to be sampled between [-1,1] to avoid extreme SDs that
    # can cause the sampler to fail
    init = 1

    # return the list
    out <- nlist(formula, data, family, prior, stanvars, init)
    return(out)
}
```

**Lines 5-10** use the `brms::custom_family` function to define a custom family for the SDM model. The `dpars` argument specifies the parameters of the model, and the `links` argument specifies the link functions for the parameters. For more information, see [here](https://cran.r-project.org/web/packages/brms/vignettes/brms_customfamilies.html)

**Lines 13-19** read the custom STAN code from the `inst/stan_chunks` directory. This has to be specified with the system.file() command to ensure that the code is found when the package is installed. The `stanvars` object is used to pass custom STAN code to the `brms` package. The `stanvars` object is a list of `brms::stanvar` objects, each of which contains the STAN code for a specific part of the model. There is a separate `.stan` file for each part of the STAN code, and each file is read into a separate `brms::stanvar` object.

Converting the `bmmformula` to a `brmsformula`, specifying priors for fixed parameters, and collecting all arguements is the same as for the IMM model.

We will now look at how to construct all these parts for a new model. **Hint**: you don't have to do it manually, you can use the `use_model_template()` function to generate templates for your model.
